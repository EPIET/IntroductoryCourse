---
title: "SimOb_Rinjects"
format: html
editor: visual
---

## 1. Install packages and load libraries

```{r, Packages}
# Check if the 'pacman' package is installed, if not install it:
if (!requireNamespace("pacman", quietly = TRUE)) install.packages("pacman")

# Load the required libraries into the current R session:
pacman::p_load(rio, 
               here, 
               tidyverse, 
               skimr,
               plyr,
               janitor,
               lubridate,
               gtsummary, 
               flextable,
               officer,
               epikit, 
               apyramid, 
               scales)

# Load EpiStats from Github:
# pacman::p_load_gh("Epiconcept-Paris/EpiStats")
# pacman::p_load_gh("Epiconcept-Paris/EpiStats@release_1.4-1_2020-04-21")
```

## 2. Import your data

```{r, Import_data}
# Import the raw data set:
linelist <- rio::import(here::here("data", "Copenhagen_raw.csv"))
```

## 3. Explore and clean your data

```{r, Explore_data}
head(linelist)
dim(linelist)
str(linelist)
skimr::skim(linelist)
names(linelist)

```

### Modify variables format

We want to modify the "variable format" or "column type" of many variables, so that we can do future calculations with them.

| Variable name                                                                                               | Original  | Desired | Hint |
|--------------------|------------------|------------------|------------------|
| sex                                                                                                         | character | factor  |      |
| group                                                                                                       | integer   | factor  |      |
| class                                                                                                       | integer   | factor  |      |
| All the clinical symptom variables                                                                          | integer   | logical |      |
| All the food variables                                                                                      | integer   | logical |      |
| All the food variables representing the amount of specific foods eaten (those finishing with a capital "D") | integer   | factor  |      |
| dayonset                                                                                                    | character | date    |      |
| starthour                                                                                                   | integer   |         |      |

: Variable types to modify

#### Sex, group and class

Let's start transforming one-by-one the first three variables in the table: `sex`, `group`, and `class`. We will also provide labels to the variable `group` with `plyr::revalue`, as 0 and 1 can be difficult to interpret when these mean something other than "no" and "yes", respectively.

```{r, mutate_simple}
#| output: false

linelist <- linelist %>% 
  dplyr::mutate(
    sex = as.factor(sex),
    group = as.factor(group),
    group = plyr::revalue(
      group, c("0" = "teacher", "1" = "student")),
    class = as.factor(class))
 
```

#### Symptoms and Food variables

For these variables, we are going to show you a couple of different ways to carry out the same variable type transformation in a *set* of variables, so you don't need to do one variable at a time. We are showing you these ways so you see alternative ways to do the same thing.

1.  For the variables that are clinical symptoms, we will list them one by one and show you the use of `mutate(across( ))`.

```{r, mutate_cs}
#| output: false

linelist <- linelist %>% 
  dplyr::mutate(
    # clinical symptoms
    across(c(diarrhoea, bloody, vomiting,
             abdo, nausea, fever,headache, jointpain), 
           ~as.logical(.)
           )
    )
```

2.  For the variables that are food items and food doses, we will show you how to first create a vector of names, following by how to the use of `mutate(across(all_of( )))` on this vector.

```{r, mutate_food}
#| output: false

# Create a vector with all the food variables representing the amount of specific foods items eaten (those finishing with a capital "D")
food_dose <- linelist %>% 
    select(ends_with("D", ignore.case = FALSE)) %>% 
    names()
food_dose <- c("tunaD", "shrimpsD", "greenD", "vealD", 
                "pastaD", "rocketD", "sauceD", "breadD",
                "champagneD", "beerD", "redwineD", "whitewineD")

# Create a vecor with all food items. To do this, we can remove the capital D of food_dose by using gsub() to replace the pattern "D" by nothing ("").
food_items <- gsub("D", "", food_dose)
# Add variable "meal"
food_items <- c(food_items, "meal") 


linelist <- linelist %>% 
  dplyr::mutate(
    # food dose variables
    across(all_of(food_dose), ~as.factor(.)),
    # food items variables
    across(all_of(food_items), ~as.logical(.))) 
  
```

***Note***: The tilde (`~`) bellow is used to apply the transformation `as.logical(.)` to each selected column, which in our case is either all columns included in `food_items` and `food_dose.`

#### Date and time variables

You can use `lubridate::dmy()` to mutate the `dayonset` variable into a date variable. Note that we are using the function `dmy()` because dates are formatted as day, then month (abbreviated character string), then year (i.e. "12nov2006").

```{r correct_date_format}
# Have a look at how the data is stored
head(linelist$dayonset)
class(linelist$dayonset)

# Update linelist:
linelist <- linelist %>% 
  # Change column to date class:
  dplyr::mutate(dayonset = lubridate::dmy(dayonset))

# Check class of updated column:
class(linelist$dayonset)
```

Having a variable that defines \"time\" in an outbreak investigation can be very useful when creating a case definition. An hour of the day, without a date associated with it doesn\'t help you much, thus, you should merge together day and time of onset of symptoms into a single variable. We can combine these two variables by using the `lubridate::ymd_h()` function.

Before we proceed, it would be wise to check if any respondents have a value for `dayonset` but not `starthour`, or vice versa. The `lubridate` date-time conversion functions do not have an explicit argument for dealing with missing values, but the `truncated = â€¦` argument can help prevent spurious date-times being derived from a date-time combination where one value is missing.

We can check if we have any missing values by cross-tabulating `starthour` with `dayonset`:

```{r crosstab_dayonset_starthour}
# Cross-tabulate dayonset with starthour:
janitor::tabyl(dat = linelist, 
               starthour, 
               dayonset)
```

This shows us that there are two respondents who had an onset date, but are missing onset time (`starthour`). Since `starthour` is represented by 1 - 2 digits, we can specify that we want `lubridate` to also parse date-time combinations that are truncated by up to two digits:

```{r combine_date_time}
linelist <- linelist %>% 
  # Combine dayonset and starthour in a new date time variable:
  mutate(onset_datetime = lubridate::ymd_h(paste(dayonset, starthour), 
                                           # Deal with missing starthour:
                                           truncated = 2))
```

Note that we needed to paste `dayonset` and `starthour` together before we could convert the variable to a date-time object. This is because the function expects a single character string, containing both the date and the time, as input.

The argument `truncated = 2` will result in dates with missing `starthour` still being converted to date-time, with the missing time being set to `00:00` (midnight). Whether you want to deal with missing `starthour` in this way or prefer to code these date-times as `NA` will depend on how you want them to be represented in your analysis.

Now we can check that everything in the new combined date-time variable has parsed correctly:

```{r check_onset_datetime}
head(linelist$dayonset)
head(linelist$starthour)
head(linelist$onset_datetime)
```

If you want to put it all together, you would have:

```{r, mutate_vectors}
# Create a vector with all the food variables representing the amount of specific foods items eaten (those finishing with a capital "D")
food_dose <- linelist %>% 
    select(ends_with("D", ignore.case = FALSE)) %>% 
    names()
food_dose <- c("tunaD", "shrimpsD", "greenD", "vealD", 
                "pastaD", "rocketD", "sauceD", "breadD",
                "champagneD", "beerD", "redwineD", "whitewineD")

# Create a vecor with all food items. To do this, we can remove the capital D of food_dose by using gsub() to replace the pattern "D" by nothing ("").
food_items <- gsub("D", "", food_dose)
# Add variable "meal"
food_items <- c(food_items, "meal") 


linelist <- linelist %>% 
  dplyr::mutate(
    sex = as.factor(sex),
    group = as.factor(group),
    group = plyr::revalue(
      group, c("0" = "teacher", "1" = "student")),
    class = as.factor(class)) %>%
  # clinical symptoms variables
  dplyr::mutate(
        across(c(diarrhoea, bloody, vomiting,
                 abdo, nausea, fever, 
                 headache, jointpain), ~as.logical(.)),
        # food dose variables
        across(all_of(food_dose), ~as.factor(.)),
        # food items variables
        across(all_of(food_items), ~as.logical(.))
        ) 
  

```

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

## Running Code

When you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:

```{r}
1 + 1
```

You can add options to executable code like this

```{r}
#| echo: false
2 * 2
```

The `echo: false` option disables the printing of code (only output is displayed).
